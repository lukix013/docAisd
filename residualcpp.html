<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>residual.cpp – Dokumentacja</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
</head>
<body>
  <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
    <div class="container-fluid">
      <a class="navbar-brand" href="index.html">← Powrót do strony głównej</a>
      <span class="navbar-text ms-auto">Plik: <code>residual.cpp</code></span>
    </div>
  </nav>

  <div class="container mt-4">
    <h1 class="mb-4">📄 Plik: <code>residual.cpp</code></h1>
    <p>Implementacja klasy <code>ResidualNetwork</code> do obsługi sieci residualnej, umożliwiającej obliczanie <code>max flow</code> i <code>min cost max flow</code> w grafie.</p>

    <h3>Klasa <code>ResidualNetwork</code></h3>
    <p>Reprezentuje graf residualny z krawędziami (<code>Edge</code>) zawierającymi <code>capacity</code>, <code>flow</code> i <code>repairCost</code>. Umożliwia dodawanie krawędzi, wyszukiwanie ścieżek powiększających i realizację algorytmów przepływowych.</p>

    <h3>Główne metody</h3>
    <ul>
      <li><code>ResidualNetwork(int vertices)</code> – konstruktor inicjalizujący wektor <code>adjList</code> o rozmiarze <code>vertices</code>.</li>
      <li><code>void addEdge(int from, int to, int capacity)</code> – dodaje krawędź bez kosztu.</li>
      <li><code>void addEdge(int from, int to, int capacity, int cost)</code> – dodaje krawędź z kosztami (<code>repairCost</code>).</li>
      <li><code>bool bfs(int source, int sink, std::vector&lt;Edge*&gt;&amp; parent)</code> – szuka ścieżki powiększającej (do <code>maxFlow</code>).</li>
      <li><code>int maxFlow(int source, int sink)</code> – oblicza maksymalny przepływ metodą Edmondsa-Karpa.</li>
      <li><code>bool bellmanFord(int source, int sink, std::vector&lt;Edge*&gt;&amp; parent)</code> – znajduje najtańsze ścieżki (koszt minimalny).</li>
      <li><code>bool findNegativeCycle(std::vector&lt;Edge*&gt; &amp;cycle)</code> – wykrywa ujemne cykle w grafie.</li>
      <li><code>void cancelNegativeCycles()</code> – usuwa ujemne cykle przez zwiększenie przepływu.</li>
      <li><code>std::pair&lt;int, int&gt; minCostMaxFlow(int source, int sink)</code> – zwraca parę: <code>maxFlow</code> i <code>minrepairCost</code>.</li>
      <li><code>void setCoordinates(int vertex, Point p)</code> – ustawia współrzędne punktu w mapie <code>coordinates</code>.</li>
      <li><code>void printCoordinates()</code> – wypisuje współrzędne wszystkich wierzchołków.</li>
    </ul>

    <h3>Opis działania</h3>
    <p>Sieć residualna przechowuje krawędzie (<code>Edge*</code>) z polami: <code>capacity</code>, <code>flow</code>, <code>repairCost</code>, oraz wskaźnikiem na krawędź odwrotną (<code>reverse</code>).</p>
    <p>Algorytmy <code>maxFlow</code> wykorzystują <code>BFS</code>, a <code>minCostMaxFlow</code> używa <code>Bellman-Ford</code> i obsługuje ujemne cykle.</p>

    <h3>Uwagi techniczne</h3>
    <ul>
      <li>Krawędzie są alokowane dynamicznie jako obiekty <code>Edge</code> z powiązanymi krawędziami odwrotnymi.</li>
      <li>Metoda <code>setCoordinates</code> przydaje się do powiązania wierzchołków z danymi geometrycznymi.</li>
    </ul>
  </div>

  <footer class="bg-light text-center py-3 mt-5">
    <small>&copy; 2025 Projekt Na AiSD II. Wszelkie prawa zastrzeżone.</small>
  </footer>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
