<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>residual.cpp â€“ Dokumentacja</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
</head>
<body>
  <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
    <div class="container-fluid">
      <a class="navbar-brand" href="index.html">â† PowrÃ³t do strony gÅ‚Ã³wnej</a>
      <span class="navbar-text ms-auto">Plik: <code>residual.cpp</code></span>
    </div>
  </nav>

  <div class="container mt-4">
    <h1 class="mb-4">ğŸ“„ Plik: <code>residual.cpp</code></h1>
    <p>Implementacja klasy <code>ResidualNetwork</code> do obsÅ‚ugi sieci residualnej, umoÅ¼liwiajÄ…cej obliczanie <code>max flow</code> i <code>min cost max flow</code> w grafie.</p>

    <h3>Klasa <code>ResidualNetwork</code></h3>
    <p>Reprezentuje graf residualny z krawÄ™dziami (<code>Edge</code>) zawierajÄ…cymi <code>capacity</code>, <code>flow</code> i <code>repairCost</code>. UmoÅ¼liwia dodawanie krawÄ™dzi, wyszukiwanie Å›cieÅ¼ek powiÄ™kszajÄ…cych i realizacjÄ™ algorytmÃ³w przepÅ‚ywowych.</p>

    <h3>GÅ‚Ã³wne metody</h3>
    <ul>
      <li><code>ResidualNetwork(int vertices)</code> â€“ konstruktor inicjalizujÄ…cy wektor <code>adjList</code> o rozmiarze <code>vertices</code>.</li>
      <li><code>void addEdge(int from, int to, int capacity)</code> â€“ dodaje krawÄ™dÅº bez kosztu.</li>
      <li><code>void addEdge(int from, int to, int capacity, int cost)</code> â€“ dodaje krawÄ™dÅº z kosztami (<code>repairCost</code>).</li>
      <li><code>bool bfs(int source, int sink, std::vector&lt;Edge*&gt;&amp; parent)</code> â€“ szuka Å›cieÅ¼ki powiÄ™kszajÄ…cej (do <code>maxFlow</code>).</li>
      <li><code>int maxFlow(int source, int sink)</code> â€“ oblicza maksymalny przepÅ‚yw metodÄ… Edmondsa-Karpa.</li>
      <li><code>bool bellmanFord(int source, int sink, std::vector&lt;Edge*&gt;&amp; parent)</code> â€“ znajduje najtaÅ„sze Å›cieÅ¼ki (koszt minimalny).</li>
      <li><code>bool findNegativeCycle(std::vector&lt;Edge*&gt; &amp;cycle)</code> â€“ wykrywa ujemne cykle w grafie.</li>
      <li><code>void cancelNegativeCycles()</code> â€“ usuwa ujemne cykle przez zwiÄ™kszenie przepÅ‚ywu.</li>
      <li><code>std::pair&lt;int, int&gt; minCostMaxFlow(int source, int sink)</code> â€“ zwraca parÄ™: <code>maxFlow</code> i <code>minrepairCost</code>.</li>
      <li><code>void setCoordinates(int vertex, Point p)</code> â€“ ustawia wspÃ³Å‚rzÄ™dne punktu w mapie <code>coordinates</code>.</li>
      <li><code>void printCoordinates()</code> â€“ wypisuje wspÃ³Å‚rzÄ™dne wszystkich wierzchoÅ‚kÃ³w.</li>
    </ul>

    <h3>Opis dziaÅ‚ania</h3>
    <p>SieÄ‡ residualna przechowuje krawÄ™dzie (<code>Edge*</code>) z polami: <code>capacity</code>, <code>flow</code>, <code>repairCost</code>, oraz wskaÅºnikiem na krawÄ™dÅº odwrotnÄ… (<code>reverse</code>).</p>
    <p>Algorytmy <code>maxFlow</code> wykorzystujÄ… <code>BFS</code>, a <code>minCostMaxFlow</code> uÅ¼ywa <code>Bellman-Ford</code> i obsÅ‚uguje ujemne cykle.</p>

    <h3>Uwagi techniczne</h3>
    <ul>
      <li>KrawÄ™dzie sÄ… alokowane dynamicznie jako obiekty <code>Edge</code> z powiÄ…zanymi krawÄ™dziami odwrotnymi.</li>
      <li>Metoda <code>setCoordinates</code> przydaje siÄ™ do powiÄ…zania wierzchoÅ‚kÃ³w z danymi geometrycznymi.</li>
    </ul>
  </div>

  <footer class="bg-light text-center py-3 mt-5">
    <small>&copy; 2025 Projekt Na AiSD II. Wszelkie prawa zastrzeÅ¼one.</small>
  </footer>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
